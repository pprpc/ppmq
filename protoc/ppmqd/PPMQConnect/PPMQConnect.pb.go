// Code generated by protoc-gen-go. DO NOT EDIT.
// source: PPMQConnect.proto

package PPMQConnect

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reqest
type Req struct {
	Account  string `protobuf:"bytes,1,opt,name=account,proto3" json:"account"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password"`
	ClientId string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id"`
	// 当前连接是否需要获取离线记录; 1 不获取，只用于接收新消息； 2 只用于获取离线消息； 3 同时获取新消息和离线消息.
	HistorymsgType int32 `protobuf:"varint,4,opt,name=historymsg_type,json=historymsgType,proto3" json:"historymsg_type"`
	// 可以设定获取离线消息的数量，默认是5条；0 表示获取所有(historymsg_type = 2,3)
	HistorymsgCount int32 `protobuf:"varint,5,opt,name=historymsg_count,json=historymsgCount,proto3" json:"historymsg_count"`
	// 0: 表示记录该ClientID的订阅信息以及服务QOS1，2的消息，在该ClientID上线后再推送该消息给对方.
	// 1: 会话仅仅维持当前连接（订阅信息会清除）
	ClearSession int32 `protobuf:"varint,6,opt,name=clear_session,json=clearSession,proto3" json:"clear_session"`
	// 1:发布一条遗嘱消息
	WillFlag uint32 `protobuf:"varint,9,opt,name=will_flag,json=willFlag,proto3" json:"will_flag"`
	// 遗嘱消息的QOS
	WillQos uint32 `protobuf:"varint,10,opt,name=will_qos,json=willQos,proto3" json:"will_qos"`
	// 是否保留遗嘱消息.1 当作保留信息发布；0 非保留信息发布.
	WillRetain uint32 `protobuf:"varint,11,opt,name=will_retain,json=willRetain,proto3" json:"will_retain"`
	// 遗嘱主题/消息
	WillTopic            string   `protobuf:"bytes,12,opt,name=will_topic,json=willTopic,proto3" json:"will_topic"`
	WillBody             string   `protobuf:"bytes,13,opt,name=will_body,json=willBody,proto3" json:"will_body"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Req) Reset()         { *m = Req{} }
func (m *Req) String() string { return proto.CompactTextString(m) }
func (*Req) ProtoMessage()    {}
func (*Req) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4754e37a4f266fe, []int{0}
}

func (m *Req) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Req.Unmarshal(m, b)
}
func (m *Req) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Req.Marshal(b, m, deterministic)
}
func (m *Req) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Req.Merge(m, src)
}
func (m *Req) XXX_Size() int {
	return xxx_messageInfo_Req.Size(m)
}
func (m *Req) XXX_DiscardUnknown() {
	xxx_messageInfo_Req.DiscardUnknown(m)
}

var xxx_messageInfo_Req proto.InternalMessageInfo

func (m *Req) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Req) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Req) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Req) GetHistorymsgType() int32 {
	if m != nil {
		return m.HistorymsgType
	}
	return 0
}

func (m *Req) GetHistorymsgCount() int32 {
	if m != nil {
		return m.HistorymsgCount
	}
	return 0
}

func (m *Req) GetClearSession() int32 {
	if m != nil {
		return m.ClearSession
	}
	return 0
}

func (m *Req) GetWillFlag() uint32 {
	if m != nil {
		return m.WillFlag
	}
	return 0
}

func (m *Req) GetWillQos() uint32 {
	if m != nil {
		return m.WillQos
	}
	return 0
}

func (m *Req) GetWillRetain() uint32 {
	if m != nil {
		return m.WillRetain
	}
	return 0
}

func (m *Req) GetWillTopic() string {
	if m != nil {
		return m.WillTopic
	}
	return ""
}

func (m *Req) GetWillBody() string {
	if m != nil {
		return m.WillBody
	}
	return ""
}

// Response
type Resp struct {
	// 0 : 如果连接使用的TCP则使用请求时的值作为心跳间隔；如果是UDP则自动探测UDP的生存时间.
	// 1-65535： TCP/UDP， 使用返回的值作为心跳间隔;
	HbInterval uint32 `protobuf:"varint,11,opt,name=hb_interval,json=hbInterval,proto3" json:"hb_interval"`
	// 连接确认标志(参见MQTT的 CONNACK的说明)
	Sp uint32 `protobuf:"varint,12,opt,name=sp,proto3" json:"sp"`
	// 参见MQTT的CONNACK的返回码定义
	Code                 uint32   `protobuf:"varint,13,opt,name=code,proto3" json:"code"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Resp) Reset()         { *m = Resp{} }
func (m *Resp) String() string { return proto.CompactTextString(m) }
func (*Resp) ProtoMessage()    {}
func (*Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4754e37a4f266fe, []int{1}
}

func (m *Resp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resp.Unmarshal(m, b)
}
func (m *Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resp.Marshal(b, m, deterministic)
}
func (m *Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resp.Merge(m, src)
}
func (m *Resp) XXX_Size() int {
	return xxx_messageInfo_Resp.Size(m)
}
func (m *Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_Resp.DiscardUnknown(m)
}

var xxx_messageInfo_Resp proto.InternalMessageInfo

func (m *Resp) GetHbInterval() uint32 {
	if m != nil {
		return m.HbInterval
	}
	return 0
}

func (m *Resp) GetSp() uint32 {
	if m != nil {
		return m.Sp
	}
	return 0
}

func (m *Resp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func init() {
	proto.RegisterType((*Req)(nil), "PPMQConnect.Req")
	proto.RegisterType((*Resp)(nil), "PPMQConnect.Resp")
}

func init() { proto.RegisterFile("PPMQConnect.proto", fileDescriptor_b4754e37a4f266fe) }

var fileDescriptor_b4754e37a4f266fe = []byte{
	// 352 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0x4f, 0x6f, 0xe2, 0x30,
	0x10, 0xc5, 0x37, 0x81, 0xf0, 0x67, 0x20, 0x2c, 0xf8, 0xe4, 0x65, 0xb5, 0x5a, 0xc4, 0x1e, 0x96,
	0xbd, 0x70, 0xd8, 0x3d, 0xec, 0xbd, 0x48, 0x95, 0x50, 0x55, 0x29, 0xb8, 0xdc, 0x23, 0xc7, 0x71,
	0xc1, 0x92, 0x1b, 0x9b, 0xd8, 0x2d, 0xca, 0x17, 0xee, 0xe7, 0xa8, 0x32, 0x29, 0x34, 0xea, 0x6d,
	0xde, 0xef, 0x8d, 0xe6, 0x8d, 0xff, 0xc0, 0x2c, 0x49, 0xee, 0x77, 0x1b, 0x53, 0x14, 0x52, 0xf8,
	0xb5, 0x2d, 0x8d, 0x37, 0x64, 0xd4, 0x42, 0xcb, 0xd7, 0x10, 0x3a, 0x4c, 0x9e, 0x08, 0x85, 0x3e,
	0x17, 0xc2, 0x3c, 0x17, 0x9e, 0x06, 0x8b, 0x60, 0x35, 0x64, 0x17, 0x49, 0xe6, 0x30, 0xb0, 0xdc,
	0xb9, 0xb3, 0x29, 0x73, 0x1a, 0xa2, 0x75, 0xd5, 0xe4, 0x3b, 0x0c, 0x85, 0x56, 0xb2, 0xf0, 0xa9,
	0xca, 0x69, 0xa7, 0x31, 0x1b, 0xb0, 0xcd, 0xc9, 0x6f, 0xf8, 0x7a, 0x54, 0xce, 0x9b, 0xb2, 0x7a,
	0x72, 0x87, 0xd4, 0x57, 0x56, 0xd2, 0xee, 0x22, 0x58, 0x45, 0x6c, 0xf2, 0x81, 0xf7, 0x95, 0x95,
	0xe4, 0x0f, 0x4c, 0x5b, 0x8d, 0xcd, 0x12, 0x11, 0x76, 0xb6, 0x06, 0x6c, 0x70, 0x99, 0x5f, 0x10,
	0x0b, 0x2d, 0x79, 0x99, 0x3a, 0xe9, 0x9c, 0x32, 0x05, 0xed, 0x61, 0xdf, 0x18, 0xe1, 0x43, 0xc3,
	0xea, 0xad, 0xce, 0x4a, 0xeb, 0xf4, 0x51, 0xf3, 0x03, 0x1d, 0x2e, 0x82, 0x55, 0xcc, 0x06, 0x35,
	0xb8, 0xd5, 0xfc, 0x40, 0xbe, 0x01, 0xd6, 0xe9, 0xc9, 0x38, 0x0a, 0xe8, 0xf5, 0x6b, 0xbd, 0x33,
	0x8e, 0xfc, 0x84, 0x11, 0x5a, 0xa5, 0xf4, 0x5c, 0x15, 0x74, 0x84, 0x2e, 0xd4, 0x88, 0x21, 0x21,
	0x3f, 0x00, 0x55, 0xea, 0x8d, 0x55, 0x82, 0x8e, 0xf1, 0xbc, 0x18, 0xb5, 0xaf, 0xc1, 0x35, 0x37,
	0x33, 0x79, 0x45, 0xe3, 0xe6, 0x36, 0x6a, 0x70, 0x63, 0xf2, 0x6a, 0x79, 0x07, 0x5d, 0x26, 0x9d,
	0xad, 0x43, 0x8e, 0x59, 0xaa, 0x0a, 0x2f, 0xcb, 0x17, 0xae, 0x2f, 0x21, 0xc7, 0x6c, 0xfb, 0x4e,
	0xc8, 0x04, 0x42, 0x67, 0x71, 0x78, 0xcc, 0x42, 0x67, 0x09, 0x81, 0xae, 0x30, 0xb9, 0xc4, 0x81,
	0x31, 0xc3, 0xfa, 0xef, 0x7f, 0x88, 0x92, 0x84, 0x59, 0x41, 0xd6, 0x10, 0x25, 0x1b, 0xae, 0x35,
	0x99, 0xae, 0xdb, 0x0f, 0xcd, 0xe4, 0x69, 0x3e, 0xfb, 0x44, 0x9c, 0x5d, 0x7e, 0xc9, 0x7a, 0xf8,
	0x05, 0xfe, 0xbd, 0x05, 0x00, 0x00, 0xff, 0xff, 0x24, 0xaf, 0x0b, 0xf0, 0x17, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PPRpcClient is the client API for PPRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PPRpcClient interface {
	PCall(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Resp, error)
}

type pPRpcClient struct {
	cc *grpc.ClientConn
}

func NewPPRpcClient(cc *grpc.ClientConn) PPRpcClient {
	return &pPRpcClient{cc}
}

func (c *pPRpcClient) PCall(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Resp, error) {
	out := new(Resp)
	err := c.cc.Invoke(ctx, "/PPMQConnect.PPRpc/PCall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PPRpcServer is the server API for PPRpc service.
type PPRpcServer interface {
	PCall(context.Context, *Req) (*Resp, error)
}

func RegisterPPRpcServer(s *grpc.Server, srv PPRpcServer) {
	s.RegisterService(&_PPRpc_serviceDesc, srv)
}

func _PPRpc_PCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PPRpcServer).PCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PPMQConnect.PPRpc/PCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PPRpcServer).PCall(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

var _PPRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "PPMQConnect.PPRpc",
	HandlerType: (*PPRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PCall",
			Handler:    _PPRpc_PCall_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "PPMQConnect.proto",
}
